`timescale 1ns / 1ps

module aes128_core (
    input  wire         clk,
    input  wire         rst_n,
    input  wire         start,
    input  wire [127:0] key,
    input  wire [127:0] plaintext,
    output wire         done,
    output wire [127:0] ciphertext
);

    // Internal registers
    reg         busy_reg;
    reg         done_reg;
    reg [3:0]   round_reg;       // 0..10
    reg [127:0] state_reg;       // current AES state
    reg [127:0] round_key_reg;   // current round key
    reg [127:0] cipher_reg;      // final ciphertext

    assign done       = done_reg;
    assign ciphertext = cipher_reg;

    // -----------------------------------------------------------------
    // Combinational round logic
    // -----------------------------------------------------------------

    // Next round key from current key and round number
    wire [127:0] next_round_key;
    aes_key_expand_128 u_keyexp (
        .current_key (round_key_reg),
        .round       (round_reg),
        .next_key    (next_round_key)
    );

    // SubBytes
    wire [127:0] subbytes_state;
    aes_subbytes u_subbytes (
        .state_in  (state_reg),
        .state_out (subbytes_state)
    );

    // ShiftRows
    wire [127:0] shiftrows_state;
    aes_shiftrows u_shiftrows (
        .state_in  (subbytes_state),
        .state_out (shiftrows_state)
    );

    // MixColumns (used only for rounds 1..9)
    wire [127:0] mixcolumns_state;
    aes_mixcolumns u_mixcolumns (
        .state_in  (shiftrows_state),
        .state_out (mixcolumns_state)
    );

    // Round output candidates
    wire [127:0] state_round_normal; // with MixColumns
    wire [127:0] state_round_final;  // without MixColumns

    assign state_round_normal = mixcolumns_state ^ next_round_key;
    assign state_round_final  = shiftrows_state ^ next_round_key;

    // -----------------------------------------------------------------
    // Control / state update
    // -----------------------------------------------------------------
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            busy_reg      <= 1'b0;
            done_reg      <= 1'b0;
            round_reg     <= 4'd0;
            state_reg     <= 128'd0;
            round_key_reg <= 128'd0;
            cipher_reg    <= 128'd0;
        end else begin
            // default
            done_reg <= 1'b0;

            if (start && !busy_reg) begin
                // Start a new encryption:
                // Initial AddRoundKey with round 0 key
                busy_reg      <= 1'b1;
                round_reg     <= 4'd1;
                state_reg     <= plaintext ^ key;
                round_key_reg <= key;
            end else if (busy_reg) begin
                if (round_reg <= 4'd9) begin
                    // Rounds 1..9: SubBytes, ShiftRows, MixColumns, AddRoundKey
                    state_reg     <= state_round_normal;
                    round_key_reg <= next_round_key;
                    round_reg     <= round_reg + 4'd1;
                end else begin
                    // Round 10 (final): SubBytes, ShiftRows, AddRoundKey (no MixColumns)
                    state_reg     <= state_round_final;
                    round_key_reg <= next_round_key;
                    cipher_reg    <= state_round_final;
                    done_reg      <= 1'b1;
                    busy_reg      <= 1'b0;
                    round_reg     <= 4'd0;
                end
            end
        end
    end

endmodule

// =====================================================================
// SubBytes: apply S-box to each byte of the 128-bit state
// =====================================================================
module aes_subbytes (
    input  wire [127:0] state_in,
    output reg  [127:0] state_out
);
    integer i;
    reg [7:0] b;

    always @* begin
        state_out = 128'd0;
        // Byte 0 = bits [127:120], Byte 1 = [119:112], ..., Byte 15 = [7:0]
        for (i = 0; i < 16; i = i + 1) begin
            b = state_in[127 - 8*i -: 8];
            state_out[127 - 8*i -: 8] = aes_sbox(b);
        end
    end

    // AES S-box as a function (full 256-entry table)
    function [7:0] aes_sbox;
        input [7:0] x;
        begin
            case (x)
                8'h00: aes_sbox = 8'h63; 8'h01: aes_sbox = 8'h7C;
                8'h02: aes_sbox = 8'h77; 8'h03: aes_sbox = 8'h7B;
                8'h04: aes_sbox = 8'hF2; 8'h05: aes_sbox = 8'h6B;
                8'h06: aes_sbox = 8'h6F; 8'h07: aes_sbox = 8'hC5;
                8'h08: aes_sbox = 8'h30; 8'h09: aes_sbox = 8'h01;
                8'h0A: aes_sbox = 8'h67; 8'h0B: aes_sbox = 8'h2B;
                8'h0C: aes_sbox = 8'hFE; 8'h0D: aes_sbox = 8'hD7;
                8'h0E: aes_sbox = 8'hAB; 8'h0F: aes_sbox = 8'h76;

                8'h10: aes_sbox = 8'hCA; 8'h11: aes_sbox = 8'h82;
                8'h12: aes_sbox = 8'hC9; 8'h13: aes_sbox = 8'h7D;
                8'h14: aes_sbox = 8'hFA; 8'h15: aes_sbox = 8'h59;
                8'h16: aes_sbox = 8'h47; 8'h17: aes_sbox = 8'hF0;
                8'h18: aes_sbox = 8'hAD; 8'h19: aes_sbox = 8'hD4;
                8'h1A: aes_sbox = 8'hA2; 8'h1B: aes_sbox = 8'hAF;
                8'h1C: aes_sbox = 8'h9C; 8'h1D: aes_sbox = 8'hA4;
                8'h1E: aes_sbox = 8'h72; 8'h1F: aes_sbox = 8'hC0;

                8'h20: aes_sbox = 8'hB7; 8'h21: aes_sbox = 8'hFD;
                8'h22: aes_sbox = 8'h93; 8'h23: aes_sbox = 8'h26;
                8'h24: aes_sbox = 8'h36; 8'h25: aes_sbox = 8'h3F;
                8'h26: aes_sbox = 8'hF7; 8'h27: aes_sbox = 8'hCC;
                8'h28: aes_sbox = 8'h34; 8'h29: aes_sbox = 8'hA5;
                8'h2A: aes_sbox = 8'hE5; 8'h2B: aes_sbox = 8'hF1;
                8'h2C: aes_sbox = 8'h71; 8'h2D: aes_sbox = 8'hD8;
                8'h2E: aes_sbox = 8'h31; 8'h2F: aes_sbox = 8'h15;

                8'h30: aes_sbox = 8'h04; 8'h31: aes_sbox = 8'hC7;
                8'h32: aes_sbox = 8'h23; 8'h33: aes_sbox = 8'hC3;
                8'h34: aes_sbox = 8'h18; 8'h35: aes_sbox = 8'h96;
                8'h36: aes_sbox = 8'h05; 8'h37: aes_sbox = 8'h9A;
                8'h38: aes_sbox = 8'h07; 8'h39: aes_sbox = 8'h12;
                8'h3A: aes_sbox = 8'h80; 8'h3B: aes_sbox = 8'hE2;
                8'h3C: aes_sbox = 8'hEB; 8'h3D: aes_sbox = 8'h27;
                8'h3E: aes_sbox = 8'hB2; 8'h3F: aes_sbox = 8'h75;

                8'h40: aes_sbox = 8'h09; 8'h41: aes_sbox = 8'h83;
                8'h42: aes_sbox = 8'h2C; 8'h43: aes_sbox = 8'h1A;
                8'h44: aes_sbox = 8'h1B; 8'h45: aes_sbox = 8'h6E;
                8'h46: aes_sbox = 8'h5A; 8'h47: aes_sbox = 8'hA0;
                8'h48: aes_sbox = 8'h52; 8'h49: aes_sbox = 8'h3B;
                8'h4A: aes_sbox = 8'hD6; 8'h4B: aes_sbox = 8'hB3;
                8'h4C: aes_sbox = 8'h29; 8'h4D: aes_sbox = 8'hE3;
                8'h4E: aes_sbox = 8'h2F; 8'h4F: aes_sbox = 8'h84;

                8'h50: aes_sbox = 8'h53; 8'h51: aes_sbox = 8'hD1;
                8'h52: aes_sbox = 8'h00; 8'h53: aes_sbox = 8'hED;
                8'h54: aes_sbox = 8'h20; 8'h55: aes_sbox = 8'hFC;
                8'h56: aes_sbox = 8'hB1; 8'h57: aes_sbox = 8'h5B;
                8'h58: aes_sbox = 8'h6A; 8'h59: aes_sbox = 8'hCB;
                8'h5A: aes_sbox = 8'hBE; 8'h5B: aes_sbox = 8'h39;
                8'h5C: aes_sbox = 8'h4A; 8'h5D: aes_sbox = 8'h4C;
                8'h5E: aes_sbox = 8'h58; 8'h5F: aes_sbox = 8'hCF;

                8'h60: aes_sbox = 8'hD0; 8'h61: aes_sbox = 8'hEF;
                8'h62: aes_sbox = 8'hAA; 8'h63: aes_sbox = 8'hFB;
                8'h64: aes_sbox = 8'h43; 8'h65: aes_sbox = 8'h4D;
                8'h66: aes_sbox = 8'h33; 8'h67: aes_sbox = 8'h85;
                8'h68: aes_sbox = 8'h45; 8'h69: aes_sbox = 8'hF9;
                8'h6A: aes_sbox = 8'h02; 8'h6B: aes_sbox = 8'h7F;
                8'h6C: aes_sbox = 8'h50; 8'h6D: aes_sbox = 8'h3C;
                8'h6E: aes_sbox = 8'h9F; 8'h6F: aes_sbox = 8'hA8;

                8'h70: aes_sbox = 8'h51; 8'h71: aes_sbox = 8'hA3;
                8'h72: aes_sbox = 8'h40; 8'h73: aes_sbox = 8'h8F;
                8'h74: aes_sbox = 8'h92; 8'h75: aes_sbox = 8'h9D;
                8'h76: aes_sbox = 8'h38; 8'h77: aes_sbox = 8'hF5;
                8'h78: aes_sbox = 8'hBC; 8'h79: aes_sbox = 8'hB6;
                8'h7A: aes_sbox = 8'hDA; 8'h7B: aes_sbox = 8'h21;
                8'h7C: aes_sbox = 8'h10; 8'h7D: aes_sbox = 8'hFF;
                8'h7E: aes_sbox = 8'hF3; 8'h7F: aes_sbox = 8'hD2;

                8'h80: aes_sbox = 8'hCD; 8'h81: aes_sbox = 8'h0C;
                8'h82: aes_sbox = 8'h13; 8'h83: aes_sbox = 8'hEC;
                8'h84: aes_sbox = 8'h5F; 8'h85: aes_sbox = 8'h97;
                8'h86: aes_sbox = 8'h44; 8'h87: aes_sbox = 8'h17;
                8'h88: aes_sbox = 8'hC4; 8'h89: aes_sbox = 8'hA7;
                8'h8A: aes_sbox = 8'h7E; 8'h8B: aes_sbox = 8'h3D;
                8'h8C: aes_sbox = 8'h64; 8'h8D: aes_sbox = 8'h5D;
                8'h8E: aes_sbox = 8'h19; 8'h8F: aes_sbox = 8'h73;

                8'h90: aes_sbox = 8'h60; 8'h91: aes_sbox = 8'h81;
                8'h92: aes_sbox = 8'h4F; 8'h93: aes_sbox = 8'hDC;
                8'h94: aes_sbox = 8'h22; 8'h95: aes_sbox = 8'h2A;
                8'h96: aes_sbox = 8'h90; 8'h97: aes_sbox = 8'h88;
                8'h98: aes_sbox = 8'h46; 8'h99: aes_sbox = 8'hEE;
                8'h9A: aes_sbox = 8'hB8; 8'h9B: aes_sbox = 8'h14;
                8'h9C: aes_sbox = 8'hDE; 8'h9D: aes_sbox = 8'h5E;
                8'h9E: aes_sbox = 8'h0B; 8'h9F: aes_sbox = 8'hDB;

                8'hA0: aes_sbox = 8'hE0; 8'hA1: aes_sbox = 8'h32;
                8'hA2: aes_sbox = 8'h3A; 8'hA3: aes_sbox = 8'h0A;
                8'hA4: aes_sbox = 8'h49; 8'hA5: aes_sbox = 8'h06;
                8'hA6: aes_sbox = 8'h24; 8'hA7: aes_sbox = 8'h5C;
                8'hA8: aes_sbox = 8'hC2; 8'hA9: aes_sbox = 8'hD3;
                8'hAA: aes_sbox = 8'hAC; 8'hAB: aes_sbox = 8'h62;
                8'hAC: aes_sbox = 8'h91; 8'hAD: aes_sbox = 8'h95;
                8'hAE: aes_sbox = 8'hE4; 8'hAF: aes_sbox = 8'h79;

                8'hB0: aes_sbox = 8'hE7; 8'hB1: aes_sbox = 8'hC8;
                8'hB2: aes_sbox = 8'h37; 8'hB3: aes_sbox = 8'h6D;
                8'hB4: aes_sbox = 8'h8D; 8'hB5: aes_sbox = 8'hD5;
                8'hB6: aes_sbox = 8'h4E; 8'hB7: aes_sbox = 8'hA9;
                8'hB8: aes_sbox = 8'h6C; 8'hB9: aes_sbox = 8'h56;
                8'hBA: aes_sbox = 8'hF4; 8'hBB: aes_sbox = 8'hEA;
                8'hBC: aes_sbox = 8'h65; 8'hBD: aes_sbox = 8'h7A;
                8'hBE: aes_sbox = 8'hAE; 8'hBF: aes_sbox = 8'h08;

                8'hC0: aes_sbox = 8'hBA; 8'hC1: aes_sbox = 8'h78;
                8'hC2: aes_sbox = 8'h25; 8'hC3: aes_sbox = 8'h2E;
                8'hC4: aes_sbox = 8'h1C; 8'hC5: aes_sbox = 8'hA6;
                8'hC6: aes_sbox = 8'hB4; 8'hC7: aes_sbox = 8'hC6;
                8'hC8: aes_sbox = 8'hE8; 8'hC9: aes_sbox = 8'hDD;
                8'hCA: aes_sbox = 8'h74; 8'hCB: aes_sbox = 8'h1F;
                8'hCC: aes_sbox = 8'h4B; 8'hCD: aes_sbox = 8'hBD;
                8'hCE: aes_sbox = 8'h8B; 8'hCF: aes_sbox = 8'h8A;

                8'hD0: aes_sbox = 8'h70; 8'hD1: aes_sbox = 8'h3E;
                8'hD2: aes_sbox = 8'hB5; 8'hD3: aes_sbox = 8'h66;
                8'hD4: aes_sbox = 8'h48; 8'hD5: aes_sbox = 8'h03;
                8'hD6: aes_sbox = 8'hF6; 8'hD7: aes_sbox = 8'h0E;
                8'hD8: aes_sbox = 8'h61; 8'hD9: aes_sbox = 8'h35;
                8'hDA: aes_sbox = 8'h57; 8'hDB: aes_sbox = 8'hB9;
                8'hDC: aes_sbox = 8'h86; 8'hDD: aes_sbox = 8'hC1;
                8'hDE: aes_sbox = 8'h1D; 8'hDF: aes_sbox = 8'h9E;

                8'hE0: aes_sbox = 8'hE1; 8'hE1: aes_sbox = 8'hF8;
                8'hE2: aes_sbox = 8'h98; 8'hE3: aes_sbox = 8'h11;
                8'hE4: aes_sbox = 8'h69; 8'hE5: aes_sbox = 8'hD9;
                8'hE6: aes_sbox = 8'h8E; 8'hE7: aes_sbox = 8'h94;
                8'hE8: aes_sbox = 8'h9B; 8'hE9: aes_sbox = 8'h1E;
                8'hEA: aes_sbox = 8'h87; 8'hEB: aes_sbox = 8'hE9;
                8'hEC: aes_sbox = 8'hCE; 8'hED: aes_sbox = 8'h55;
                8'hEE: aes_sbox = 8'h28; 8'hEF: aes_sbox = 8'hDF;

                8'hF0: aes_sbox = 8'h8C; 8'hF1: aes_sbox = 8'hA1;
                8'hF2: aes_sbox = 8'h89; 8'hF3: aes_sbox = 8'h0D;
                8'hF4: aes_sbox = 8'hBF; 8'hF5: aes_sbox = 8'hE6;
                8'hF6: aes_sbox = 8'h42; 8'hF7: aes_sbox = 8'h68;
                8'hF8: aes_sbox = 8'h41; 8'hF9: aes_sbox = 8'h99;
                8'hFA: aes_sbox = 8'h2D; 8'hFB: aes_sbox = 8'h0F;
                8'hFC: aes_sbox = 8'hB0; 8'hFD: aes_sbox = 8'h54;
                8'hFE: aes_sbox = 8'hBB; 8'hFF: aes_sbox = 8'h16;
            endcase
        end
    endfunction

endmodule

// =====================================================================
// ShiftRows (column-major state layout)
// State bytes indices (big-endian):
//  [  0   4   8  12 ]
//  [  1   5   9  13 ]
//  [  2   6  10  14 ]
//  [  3   7  11  15 ]
// Row0: no shift
// Row1: left shift by 1
// Row2: left shift by 2
// Row3: left shift by 3
// =====================================================================
module aes_shiftrows (
    input  wire [127:0] state_in,
    output reg  [127:0] state_out
);
    reg [7:0] s [0:15];
    reg [7:0] t [0:15];
    integer i;

    always @* begin
        // unpack bytes from state_in
        for (i = 0; i < 16; i = i + 1) begin
            s[i] = state_in[127 - 8*i -: 8];
        end

        // Row 0
        t[0]  = s[0];   t[4]  = s[4];   t[8]  = s[8];   t[12] = s[12];
        // Row 1 (1-byte left rotation)
        t[1]  = s[5];   t[5]  = s[9];   t[9]  = s[13];  t[13] = s[1];
        // Row 2 (2-byte left rotation)
        t[2]  = s[10];  t[6]  = s[14];  t[10] = s[2];   t[14] = s[6];
        // Row 3 (3-byte left rotation)
        t[3]  = s[15];  t[7]  = s[3];   t[11] = s[7];   t[15] = s[11];

        // pack back into 128-bit state_out
        state_out = 128'd0;
        for (i = 0; i < 16; i = i + 1) begin
            state_out[127 - 8*i -: 8] = t[i];
        end
    end
endmodule

// =====================================================================
// MixColumns
// Operates on each column of 4 bytes
// =====================================================================
module aes_mixcolumns (
    input  wire [127:0] state_in,
    output reg  [127:0] state_out
);
    reg [7:0] s [0:15];
    reg [7:0] t [0:15];

    integer i;
    integer c;
    reg [7:0] a0, a1, a2, a3;

    // GF(2^8) multiply by 2
    function [7:0] gm2;
        input [7:0] b;
        begin
            gm2 = (b[7] ? ((b << 1) ^ 8'h1B) : (b << 1));
        end
    endfunction

    // GF(2^8) multiply by 3 = 2*b ^ b
    function [7:0] gm3;
        input [7:0] b;
        begin
            gm3 = gm2(b) ^ b;
        end
    endfunction

    always @* begin
        // unpack
        for (i = 0; i < 16; i = i + 1) begin
            s[i] = state_in[127 - 8*i -: 8];
        end

        // process columns c = 0..3
        // column c has bytes at indices (0+4*c),(1+4*c),(2+4*c),(3+4*c)
        for (c = 0; c < 4; c = c + 1) begin
            a0 = s[0 + 4*c];
            a1 = s[1 + 4*c];
            a2 = s[2 + 4*c];
            a3 = s[3 + 4*c];

            t[0 + 4*c] = gm2(a0) ^ gm3(a1) ^ a2       ^ a3;
            t[1 + 4*c] = a0       ^ gm2(a1) ^ gm3(a2) ^ a3;
            t[2 + 4*c] = a0       ^ a1       ^ gm2(a2) ^ gm3(a3);
            t[3 + 4*c] = gm3(a0) ^ a1       ^ a2       ^ gm2(a3);
        end

        // pack
        state_out = 128'd0;
        for (i = 0; i < 16; i = i + 1) begin
            state_out[127 - 8*i -: 8] = t[i];
        end
    end

endmodule

// =====================================================================
// Key expansion: AES-128, one round at a time
// current_key -> next_key using 'round' (1..10)
// =====================================================================
module aes_key_expand_128 (
    input  wire [127:0] current_key,
    input  wire [3:0]   round,       // 1..10
    output reg  [127:0] next_key
);
    // Rcon function (only top byte used)
    function [7:0] aes_rcon;
        input [3:0] r;
        begin
            case (r)
                4'd1:  aes_rcon = 8'h01;
                4'd2:  aes_rcon = 8'h02;
                4'd3:  aes_rcon = 8'h04;
                4'd4:  aes_rcon = 8'h08;
                4'd5:  aes_rcon = 8'h10;
                4'd6:  aes_rcon = 8'h20;
                4'd7:  aes_rcon = 8'h40;
                4'd8:  aes_rcon = 8'h80;
                4'd9:  aes_rcon = 8'h1B;
                4'd10: aes_rcon = 8'h36;
                default: aes_rcon = 8'h00;
            endcase
        end
    endfunction

    // S-box function for key expansion (same table as above)
    function [7:0] aes_sbox;
        input [7:0] x;
        begin
            case (x)
                8'h00: aes_sbox = 8'h63; 8'h01: aes_sbox = 8'h7C;
                8'h02: aes_sbox = 8'h77; 8'h03: aes_sbox = 8'h7B;
                8'h04: aes_sbox = 8'hF2; 8'h05: aes_sbox = 8'h6B;
                8'h06: aes_sbox = 8'h6F; 8'h07: aes_sbox = 8'hC5;
                8'h08: aes_sbox = 8'h30; 8'h09: aes_sbox = 8'h01;
                8'h0A: aes_sbox = 8'h67; 8'h0B: aes_sbox = 8'h2B;
                8'h0C: aes_sbox = 8'hFE; 8'h0D: aes_sbox = 8'hD7;
                8'h0E: aes_sbox = 8'hAB; 8'h0F: aes_sbox = 8'h76;

                8'h10: aes_sbox = 8'hCA; 8'h11: aes_sbox = 8'h82;
                8'h12: aes_sbox = 8'hC9; 8'h13: aes_sbox = 8'h7D;
                8'h14: aes_sbox = 8'hFA; 8'h15: aes_sbox = 8'h59;
                8'h16: aes_sbox = 8'h47; 8'h17: aes_sbox = 8'hF0;
                8'h18: aes_sbox = 8'hAD; 8'h19: aes_sbox = 8'hD4;
                8'h1A: aes_sbox = 8'hA2; 8'h1B: aes_sbox = 8'hAF;
                8'h1C: aes_sbox = 8'h9C; 8'h1D: aes_sbox = 8'hA4;
                8'h1E: aes_sbox = 8'h72; 8'h1F: aes_sbox = 8'hC0;

                8'h20: aes_sbox = 8'hB7; 8'h21: aes_sbox = 8'hFD;
                8'h22: aes_sbox = 8'h93; 8'h23: aes_sbox = 8'h26;
                8'h24: aes_sbox = 8'h36; 8'h25: aes_sbox = 8'h3F;
                8'h26: aes_sbox = 8'hF7; 8'h27: aes_sbox = 8'hCC;
                8'h28: aes_sbox = 8'h34; 8'h29: aes_sbox = 8'hA5;
                8'h2A: aes_sbox = 8'hE5; 8'h2B: aes_sbox = 8'hF1;
                8'h2C: aes_sbox = 8'h71; 8'h2D: aes_sbox = 8'hD8;
                8'h2E: aes_sbox = 8'h31; 8'h2F: aes_sbox = 8'h15;

                8'h30: aes_sbox = 8'h04; 8'h31: aes_sbox = 8'hC7;
                8'h32: aes_sbox = 8'h23; 8'h33: aes_sbox = 8'hC3;
                8'h34: aes_sbox = 8'h18; 8'h35: aes_sbox = 8'h96;
                8'h36: aes_sbox = 8'h05; 8'h37: aes_sbox = 8'h9A;
                8'h38: aes_sbox = 8'h07; 8'h39: aes_sbox = 8'h12;
                8'h3A: aes_sbox = 8'h80; 8'h3B: aes_sbox = 8'hE2;
                8'h3C: aes_sbox = 8'hEB; 8'h3D: aes_sbox = 8'h27;
                8'h3E: aes_sbox = 8'hB2; 8'h3F: aes_sbox = 8'h75;

                8'h40: aes_sbox = 8'h09; 8'h41: aes_sbox = 8'h83;
                8'h42: aes_sbox = 8'h2C; 8'h43: aes_sbox = 8'h1A;
                8'h44: aes_sbox = 8'h1B; 8'h45: aes_sbox = 8'h6E;
                8'h46: aes_sbox = 8'h5A; 8'h47: aes_sbox = 8'hA0;
                8'h48: aes_sbox = 8'h52; 8'h49: aes_sbox = 8'h3B;
                8'h4A: aes_sbox = 8'hD6; 8'h4B: aes_sbox = 8'hB3;
                8'h4C: aes_sbox = 8'h29; 8'h4D: aes_sbox = 8'hE3;
                8'h4E: aes_sbox = 8'h2F; 8'h4F: aes_sbox = 8'h84;

                8'h50: aes_sbox = 8'h53; 8'h51: aes_sbox = 8'hD1;
                8'h52: aes_sbox = 8'h00; 8'h53: aes_sbox = 8'hED;
                8'h54: aes_sbox = 8'h20; 8'h55: aes_sbox = 8'hFC;
                8'h56: aes_sbox = 8'hB1; 8'h57: aes_sbox = 8'h5B;
                8'h58: aes_sbox = 8'h6A; 8'h59: aes_sbox = 8'hCB;
                8'h5A: aes_sbox = 8'hBE; 8'h5B: aes_sbox = 8'h39;
                8'h5C: aes_sbox = 8'h4A; 8'h5D: aes_sbox = 8'h4C;
                8'h5E: aes_sbox = 8'h58; 8'h5F: aes_sbox = 8'hCF;

                8'h60: aes_sbox = 8'hD0; 8'h61: aes_sbox = 8'hEF;
                8'h62: aes_sbox = 8'hAA; 8'h63: aes_sbox = 8'hFB;
                8'h64: aes_sbox = 8'h43; 8'h65: aes_sbox = 8'h4D;
                8'h66: aes_sbox = 8'h33; 8'h67: aes_sbox = 8'h85;
                8'h68: aes_sbox = 8'h45; 8'h69: aes_sbox = 8'hF9;
                8'h6A: aes_sbox = 8'h02; 8'h6B: aes_sbox = 8'h7F;
                8'h6C: aes_sbox = 8'h50; 8'h6D: aes_sbox = 8'h3C;
                8'h6E: aes_sbox = 8'h9F; 8'h6F: aes_sbox = 8'hA8;

                8'h70: aes_sbox = 8'h51; 8'h71: aes_sbox = 8'hA3;
                8'h72: aes_sbox = 8'h40; 8'h73: aes_sbox = 8'h8F;
                8'h74: aes_sbox = 8'h92; 8'h75: aes_sbox = 8'h9D;
                8'h76: aes_sbox = 8'h38; 8'h77: aes_sbox = 8'hF5;
                8'h78: aes_sbox = 8'hBC; 8'h79: aes_sbox = 8'hB6;
                8'h7A: aes_sbox = 8'hDA; 8'h7B: aes_sbox = 8'h21;
                8'h7C: aes_sbox = 8'h10; 8'h7D: aes_sbox = 8'hFF;
                8'h7E: aes_sbox = 8'hF3; 8'h7F: aes_sbox = 8'hD2;

                8'h80: aes_sbox = 8'hCD; 8'h81: aes_sbox = 8'h0C;
                8'h82: aes_sbox = 8'h13; 8'h83: aes_sbox = 8'hEC;
                8'h84: aes_sbox = 8'h5F; 8'h85: aes_sbox = 8'h97;
                8'h86: aes_sbox = 8'h44; 8'h87: aes_sbox = 8'h17;
                8'h88: aes_sbox = 8'hC4; 8'h89: aes_sbox = 8'hA7;
                8'h8A: aes_sbox = 8'h7E; 8'h8B: aes_sbox = 8'h3D;
                8'h8C: aes_sbox = 8'h64; 8'h8D: aes_sbox = 8'h5D;
                8'h8E: aes_sbox = 8'h19; 8'h8F: aes_sbox = 8'h73;

                8'h90: aes_sbox = 8'h60; 8'h91: aes_sbox = 8'h81;
                8'h92: aes_sbox = 8'h4F; 8'h93: aes_sbox = 8'hDC;
                8'h94: aes_sbox = 8'h22; 8'h95: aes_sbox = 8'h2A;
                8'h96: aes_sbox = 8'h90; 8'h97: aes_sbox = 8'h88;
                8'h98: aes_sbox = 8'h46; 8'h99: aes_sbox = 8'hEE;
                8'h9A: aes_sbox = 8'hB8; 8'h9B: aes_sbox = 8'h14;
                8'h9C: aes_sbox = 8'hDE; 8'h9D: aes_sbox = 8'h5E;
                8'h9E: aes_sbox = 8'h0B; 8'h9F: aes_sbox = 8'hDB;

                8'hA0: aes_sbox = 8'hE0; 8'hA1: aes_sbox = 8'h32;
                8'hA2: aes_sbox = 8'h3A; 8'hA3: aes_sbox = 8'h0A;
                8'hA4: aes_sbox = 8'h49; 8'hA5: aes_sbox = 8'h06;
                8'hA6: aes_sbox = 8'h24; 8'hA7: aes_sbox = 8'h5C;
                8'hA8: aes_sbox = 8'hC2; 8'hA9: aes_sbox = 8'hD3;
                8'hAA: aes_sbox = 8'hAC; 8'hAB: aes_sbox = 8'h62;
                8'hAC: aes_sbox = 8'h91; 8'hAD: aes_sbox = 8'h95;
                8'hAE: aes_sbox = 8'hE4; 8'hAF: aes_sbox = 8'h79;

                8'hB0: aes_sbox = 8'hE7; 8'hB1: aes_sbox = 8'hC8;
                8'hB2: aes_sbox = 8'h37; 8'hB3: aes_sbox = 8'h6D;
                8'hB4: aes_sbox = 8'h8D; 8'hB5: aes_sbox = 8'hD5;
                8'hB6: aes_sbox = 8'h4E; 8'hB7: aes_sbox = 8'hA9;
                8'hB8: aes_sbox = 8'h6C; 8'hB9: aes_sbox = 8'h56;
                8'hBA: aes_sbox = 8'hF4; 8'hBB: aes_sbox = 8'hEA;
                8'hBC: aes_sbox = 8'h65; 8'hBD: aes_sbox = 8'h7A;
                8'hBE: aes_sbox = 8'hAE; 8'hBF: aes_sbox = 8'h08;

                8'hC0: aes_sbox = 8'hBA; 8'hC1: aes_sbox = 8'h78;
                8'hC2: aes_sbox = 8'h25; 8'hC3: aes_sbox = 8'h2E;
                8'hC4: aes_sbox = 8'h1C; 8'hC5: aes_sbox = 8'hA6;
                8'hC6: aes_sbox = 8'hB4; 8'hC7: aes_sbox = 8'hC6;
                8'hC8: aes_sbox = 8'hE8; 8'hC9: aes_sbox = 8'hDD;
                8'hCA: aes_sbox = 8'h74; 8'hCB: aes_sbox = 8'h1F;
                8'hCC: aes_sbox = 8'h4B; 8'hCD: aes_sbox = 8'hBD;
                8'hCE: aes_sbox = 8'h8B; 8'hCF: aes_sbox = 8'h8A;

                8'hD0: aes_sbox = 8'h70; 8'hD1: aes_sbox = 8'h3E;
                8'hD2: aes_sbox = 8'hB5; 8'hD3: aes_sbox = 8'h66;
                8'hD4: aes_sbox = 8'h48; 8'hD5: aes_sbox = 8'h03;
                8'hD6: aes_sbox = 8'hF6; 8'hD7: aes_sbox = 8'h0E;
                8'hD8: aes_sbox = 8'h61; 8'hD9: aes_sbox = 8'h35;
                8'hDA: aes_sbox = 8'h57; 8'hDB: aes_sbox = 8'hB9;
                8'hDC: aes_sbox = 8'h86; 8'hDD: aes_sbox = 8'hC1;
                8'hDE: aes_sbox = 8'h1D; 8'hDF: aes_sbox = 8'h9E;

                8'hE0: aes_sbox = 8'hE1; 8'hE1: aes_sbox = 8'hF8;
                8'hE2: aes_sbox = 8'h98; 8'hE3: aes_sbox = 8'h11;
                8'hE4: aes_sbox = 8'h69; 8'hE5: aes_sbox = 8'hD9;
                8'hE6: aes_sbox = 8'h8E; 8'hE7: aes_sbox = 8'h94;
                8'hE8: aes_sbox = 8'h9B; 8'hE9: aes_sbox = 8'h1E;
                8'hEA: aes_sbox = 8'h87; 8'hEB: aes_sbox = 8'hE9;
                8'hEC: aes_sbox = 8'hCE; 8'hED: aes_sbox = 8'h55;
                8'hEE: aes_sbox = 8'h28; 8'hEF: aes_sbox = 8'hDF;

                8'hF0: aes_sbox = 8'h8C; 8'hF1: aes_sbox = 8'hA1;
                8'hF2: aes_sbox = 8'h89; 8'hF3: aes_sbox = 8'h0D;
                8'hF4: aes_sbox = 8'hBF; 8'hF5: aes_sbox = 8'hE6;
                8'hF6: aes_sbox = 8'h42; 8'hF7: aes_sbox = 8'h68;
                8'hF8: aes_sbox = 8'h41; 8'hF9: aes_sbox = 8'h99;
                8'hFA: aes_sbox = 8'h2D; 8'hFB: aes_sbox = 8'h0F;
                8'hFC: aes_sbox = 8'hB0; 8'hFD: aes_sbox = 8'h54;
                8'hFE: aes_sbox = 8'hBB; 8'hFF: aes_sbox = 8'h16;
            endcase
        end
    endfunction

    integer i;
    reg [7:0] w  [0:15];   // input key bytes
    reg [7:0] t  [0:3];    // temp word
    reg [7:0] rcon;
    reg [7:0] nw [0:15];   // new key bytes

    always @* begin
        // unpack key bytes (big-endian)
        for (i = 0; i < 16; i = i + 1) begin
            w[i] = current_key[127 - 8*i -: 8];
        end

        // RotWord (last word) and SubWord
        t[0] = aes_sbox(w[13]);
        t[1] = aes_sbox(w[14]);
        t[2] = aes_sbox(w[15]);
        t[3] = aes_sbox(w[12]);

        // XOR with Rcon in top byte
        rcon = aes_rcon(round);
        t[0] = t[0] ^ rcon;

        // New key words:
        // w'[0..3] = w[0..3] ^ t
        nw[0] = w[0] ^ t[0];
        nw[1] = w[1] ^ t[1];
        nw[2] = w[2] ^ t[2];
        nw[3] = w[3] ^ t[3];

        // w'[4..7] = w[4..7] ^ w'[0..3]
        nw[4] = w[4] ^ nw[0];
        nw[5] = w[5] ^ nw[1];
        nw[6] = w[6] ^ nw[2];
        nw[7] = w[7] ^ nw[3];

        // w'[8..11] = w[8..11] ^ w'[4..7]
        nw[8]  = w[8]  ^ nw[4];
        nw[9]  = w[9]  ^ nw[5];
        nw[10] = w[10] ^ nw[6];
        nw[11] = w[11] ^ nw[7];

        // w'[12..15] = w[12..15] ^ w'[8..11]
        nw[12] = w[12] ^ nw[8];
        nw[13] = w[13] ^ nw[9];
        nw[14] = w[14] ^ nw[10];
        nw[15] = w[15] ^ nw[11];

        // pack back into 128-bit next_key
        next_key = 128'd0;
        for (i = 0; i < 16; i = i + 1) begin
            next_key[127 - 8*i -: 8] = nw[i];
        end
    end

endmodule
